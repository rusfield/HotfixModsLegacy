@using RusBlazor.Components.Button
@typeparam T
@inject IJSRuntime JSRuntime


<div class="rus-select">
    <RusInput @ref="rusInput" TValue="string" @bind-Value="displayValue" DisplayName="test" OnFocus="OnFocus" OnBlur="OnBlur" InputChanged="InputChanged" HelperText="@($"{Value.ToString()} ({typeof(T).ToTypeDisplayName()})")" />
    <RusMenu T="T" IsOpen="menuOpen" IsOpenChanged="ShowMenuChanged">
        <ControlContent>
            <RusMenuItem Hoverable="false">
                <div style="display: flex; height: 30px;">
                    <RusButton Style="width:50%; height:100%;" OnClick="SelectFilteredAsync" Disabled="loading || !filteredItems.Any()">
                        @(filteredItems.Count == options?.Count ? "Select all" : "Select filtered")
                    </RusButton>
                    <RusButton Style="width:50%; height:100%;" OnClick="DeselectFilteredAsync" Disabled="loading || !filteredItems.Any()">
                        @(filteredItems.Count == options?.Count ? "Deselect all" : "Deselect filtered")
                    </RusButton>
                </div>
            </RusMenuItem>
        </ControlContent>
        <MenuContent>
            @if (loading)
            {
                <RusMenuItem Hoverable="false">
                    <RusMenuItemContentLoading />
                </RusMenuItem>
            }
            else if (!filteredItems.Any())
            {
                <RusMenuItem Hoverable="false">
                    <RusMenuItemContentText Text="No results" />
                </RusMenuItem>
            }
            else
            {
                foreach (var item in filteredItems)
                {
                    <RusMenuItem OnItemClick="@(async () => await SelectItemAsync(item.Key))">
                        <RusMenuItemContentKeyValue Key="@item.Key.ToString()" Value="@(item.Value)" Multiselect="true" Checked="@(selectedValues.Contains(item.Key))" />
                    </RusMenuItem>
                }
            }
        </MenuContent>
    </RusMenu>
</div>

@code {
    [Parameter]
    public T Value { get; set; }

    [Parameter]
    public EventCallback<T> ValueChanged { get; set; }

    [Parameter]
    public Func<string, CancellationToken, Task<Dictionary<T, string>>> GetOptionsAsync { get; set; }

    string id = "";
    bool loading = false;
    bool menuOpen = false;
    string? displayValue;
    string? lastVerifiedDisplayValue;
    private Timer? searchTimer;
    private CancellationTokenSource? cancellationTokenSource;
    Dictionary<T, string>? options;
    Dictionary<T, string> filteredItems = new();
    List<T> selectedValues = new();
    RusInput<string>? rusInput;
    string? rusInputId;

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            rusInputId = rusInput?.GetId() ?? "";
            selectedValues.GetFlagsByValue(Value);
        }
        base.OnAfterRender(firstRender);
    }

    void OnFocus()
    {
        // Element may be re-focused from clicking in menu too.
        if (!menuOpen)
        {
            cancellationTokenSource?.Cancel();
            cancellationTokenSource = new CancellationTokenSource();
            CancellationToken cancellationToken = cancellationTokenSource.Token;

            Task.Run(async () =>
            {
                await UpdateListAsync("", cancellationToken);
            });
        }
    }

    void OnBlur()
    {
        cancellationTokenSource?.Cancel();
    }

    void InputChanged(string input)
    {
        cancellationTokenSource?.Cancel();
        cancellationTokenSource = new CancellationTokenSource();
        CancellationToken cancellationToken = cancellationTokenSource.Token;

        searchTimer?.Dispose();
        searchTimer = new Timer(async (state) =>
        {
            if (!cancellationToken.IsCancellationRequested)
            {
                await UpdateListAsync(input, cancellationToken);
            }
        }, null, 150, Timeout.Infinite);
    }

    async Task UpdateListAsync(string search, CancellationToken token)
    {
        loading = true;
        menuOpen = true;
        await InvokeAsync(StateHasChanged);
        try
        {
            filteredItems = await SearchAsync(search, token);
        }
        catch (OperationCanceledException e)
        {
            // Search cancelled
        }
        loading = false;
        await InvokeAsync(StateHasChanged);
    }

    async Task SelectFilteredAsync()
    {
        foreach (var item in filteredItems)
        {
            if (!selectedValues.Contains(item.Key))
                selectedValues.Add(item.Key);
        }
        if (selectedValues.TrySum<T>(out var sum))
        {
            Value = sum;
            SetDisplayText();
            await JSRuntime.InvokeVoidAsync("selectElement", rusInputId);
        }
    }

    async Task DeselectFilteredAsync()
    {
        foreach (var item in filteredItems)
        {
            if (selectedValues.Contains(item.Key))
                selectedValues.Remove(item.Key);
        }
        if (selectedValues.TrySum<T>(out var sum))
        {
            Value = sum;
            SetDisplayText();
            await JSRuntime.InvokeVoidAsync("selectElement", rusInputId);
        }
    }

    async Task SelectItemAsync(T key)
    {
        // Toggle whether key is added or removed
        if (selectedValues.Contains(key))
        {
            selectedValues.Remove(key);
        }
        else
        {
            selectedValues.Add(key);
        }

        Value = selectedValues.GetValueByFlags();
        SetDisplayText();

        //_ = ValueChanged.InvokeAsync(Value);

        await JSRuntime.InvokeVoidAsync("selectElement", rusInputId);
    }

    void ShowMenuChanged(bool showMenu)
    {
        if (!showMenu)
            displayValue = lastVerifiedDisplayValue;
        menuOpen = showMenu;
    }

    async Task<Dictionary<T, string>> SearchAsync(string input, CancellationToken token)
    {
        if (options == null)
        {
            var validOptions = await GetOptionsAsync.Invoke("", token);
            token.ThrowIfCancellationRequested();

            options = new();

            // Remove key 0. This is handled by menu automatically.
            if (typeof(T).IsWholeNumberType() && options.ContainsKey(default(T)))
                options.Remove(default(T));

            foreach (var validOption in validOptions)
                options[validOption.Key] = validOption.Value;

            if (typeof(T).IsWholeNumberType() && typeof(T).TryGetMaxValue<T>(out var maxValue))
            {
                var undefinedOptions = new List<T>();
                undefinedOptions.GetFlagsByValue(maxValue);
                foreach (var undefinedOption in undefinedOptions)
                    if (!options.ContainsKey(undefinedOption))
                        options[undefinedOption] = "Undefined";
            }
        }

        var results = new Dictionary<T, string>();
        var keyMatches = new List<T>();
        if (typeof(T).IsWholeNumberType() && input.TryParseAsT<T>(out var value))
        {
            keyMatches.GetFlagsByValue(value);
        }
        keyMatches.AddRange(options.Where(v => v.Value.Contains(input, StringComparison.InvariantCultureIgnoreCase)).Select(k => k.Key));

        token.ThrowIfCancellationRequested();
        foreach (var match in keyMatches)
        {
            if (options.ContainsKey(match))
                results[match] = options[match];
            else
                results[match] = new("Undefined");
        }

        return results;
    }

    void SetDisplayText()
    {
        if (selectedValues.Count == 0)
        {
            displayValue = "None";
        }
        else if (selectedValues.Count == 1)
        {
            displayValue = options?[selectedValues.First()];
        }
        else
        {
            displayValue = $"{selectedValues.Count} selected";
        }
        lastVerifiedDisplayValue = displayValue;
    }
}