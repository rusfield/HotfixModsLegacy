@using Extensions;
@using RusBlazor.Components.Button
@typeparam T
@inject IJSRuntime JSRuntime

<div class="rus-select">
    <RusInput TValue="string" @bind-Value="displayValue" DisplayName="test" OnFocus="OnFocus" OnBlur="OnBlur" InputChanged="InputChanged" Disabled="loadingComponent" />
    <RusMenu @ref="rusMenu" T="T" IsOpen="menuOpen" IsOpenChanged="ShowMenuChanged">
        <MenuContent>
            @if (loadingSearch)
            {
                <RusMenuItem Hoverable="false">
                    <RusMenuItemContentLoading />
                </RusMenuItem>
            }
            else if (!filteredItems.Any())
            {
                <RusMenuItem Hoverable="false">
                    <RusMenuItemContentText Text="No results" />
                </RusMenuItem>
            }
            else
            {
                foreach (var item in filteredItems)
                {
                    <RusMenuItem OnItemClick="@(() => SelectItem(item.Key, item.Value))" Id="@($"{rusMenu!.GetId()}-{item.Key.ToString()}")">
                        <RusMenuItemContentKeyValue Key="@item.Key.ToString()" Value="@item.Value" />
                    </RusMenuItem>
                }
            }
        </MenuContent>
        <MenuBottomContent>
            @if (resultCount > -1)
            {
                <RusMenuItem Hoverable="false">
                    <div style="display: flex; height: 30px;">
                        <RusButton Style="width:25%;height:30px;" OnClick="PreviousPage" Disabled="currentPageIndex == 0">
                            @("<")
                        </RusButton>
                        <div style="width:50%;height:30px;">
                            @(GetPaginationText())
                        </div>
                        <RusButton Style="width:25%;height:30px;" OnClick="NextPage" Disabled="IsLastPageIndex()">
                            @(">")
                        </RusButton>
                    </div>
                </RusMenuItem>
            }
        </MenuBottomContent>
    </RusMenu>
</div>

@code {
    [Parameter]
    public T Value { get; set; }

    [Parameter]
    public EventCallback<T> ValueChanged { get; set; }

    [Parameter]
    public Func<string, int, int, CancellationToken, Task<(Dictionary<T, string>, int)>> GetOptionsAsync { get; set; }

    [Parameter]
    public Func<T, int, Task<int>> GetPageIndexByIdAsync { get; set; }

    [Parameter]
    public bool AllowUndefinedValues { get; set; } = true;

    bool loadingComponent = true;
    bool loadingSearch = false;
    bool menuOpen = false;
    string displayValue = "Loading";
    string? lastVerifiedDisplayValue;
    string lastInput = "";
    private Timer? searchTimer;
    private CancellationTokenSource? cancellationTokenSource;
    Dictionary<T, string> filteredItems = new();
    RusMenu<T>? rusMenu;
    int pageSize = 15;
    int currentPageIndex = -1;
    int resultCount = -1;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // Init default option
        if (firstRender)
        {
            (var currentValue, int tempCount) = await GetOptionsAsync(Value.ToString(), 0, 1, CancellationToken.None);
            if (currentValue.ContainsKey(Value))
            {
                displayValue = currentValue[Value];
            }
            else
            {
                displayValue = $"Unknown ({Value})";
            }
            loadingComponent = false;
            lastVerifiedDisplayValue = displayValue;
            this.StateHasChanged();
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    async Task OnFocus()
    {
        InitSearch(0);
    }

    void OnBlur()
    {
        cancellationTokenSource?.Cancel();
    }

    void InputChanged(string input)
    {
        lastInput = input;
        InitSearch(150);
    }

    void NextPage()
    {
        currentPageIndex++;
        InitSearch(0);
    }

    void PreviousPage()
    {
        currentPageIndex--;
        InitSearch(0);
    }

    void InitSearch(int searchDelayMs)
    {
        cancellationTokenSource?.Cancel();
        cancellationTokenSource = new CancellationTokenSource();
        CancellationToken cancellationToken = cancellationTokenSource.Token;

        searchTimer?.Dispose();
        searchTimer = new Timer(async (state) =>
        {
            if (!cancellationToken.IsCancellationRequested)
            {
                await SearchOptionsAsync(cancellationToken);
            }
        }, null, searchDelayMs, Timeout.Infinite);
    }

    async Task SearchOptionsAsync(CancellationToken token)
    {
        loadingSearch = true;
        menuOpen = true;
        string search = lastInput;
        await InvokeAsync(StateHasChanged);
        try
        {
            // Happens on new searches
            if(currentPageIndex < 0)
                currentPageIndex = GetPageIndexByIdAsync != null ? await GetPageIndexByIdAsync(Value, pageSize) : 0;

            if (GetOptionsAsync != null)
                (filteredItems, resultCount) = await GetOptionsAsync.Invoke(search, currentPageIndex, pageSize, token);

            // Adjust search so that a potential custom value is retrieved
            if (string.IsNullOrWhiteSpace(search))
                search = lastVerifiedDisplayValue ?? "";

            // Search for custom values
            if (AllowUndefinedValues && search.TryParseAsT<T>(out var value) && !filteredItems.ContainsKey(value))
                filteredItems.Add(value, $"Undefined ({value})");
        }
        catch (OperationCanceledException e)
        {
            // Search cancelled
        }
        loadingSearch = false;
        await InvokeAsync(StateHasChanged);
        if (filteredItems.ContainsKey(Value))
        {
            await JSRuntime.InvokeVoidAsync("scrollToElementInContainer", rusMenu!.GetId(), $"{rusMenu!.GetId()}-{Value.ToString()}", 2000);
        }
    }

    void SelectItem(T key, string value)
    {
        Value = key;
        displayValue = value;
        lastVerifiedDisplayValue = value;
        menuOpen = false;
        _ = ValueChanged.InvokeAsync(Value);
    }

    void ShowMenuChanged(bool showMenu)
    {
        if (!showMenu)
        {
            displayValue = lastVerifiedDisplayValue;
            lastInput = "";
            resultCount = -1;
            currentPageIndex = -1;
        }
        menuOpen = showMenu;
    }

    string GetPaginationText()
    {
        int from = currentPageIndex * pageSize + 1;
        int to = (currentPageIndex + 1) * pageSize;

        to = to > resultCount ? resultCount : to;
        string action = loadingSearch ? "Loading" : "Showing";

        return $"{action} {from} to {to} of {resultCount} results";
    }

    bool IsLastPageIndex()
    {
        return ((currentPageIndex + 1) * pageSize) >= resultCount;
    }
}

