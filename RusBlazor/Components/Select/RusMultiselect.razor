@using RusBlazor.Extensions;
@typeparam T
@inject IJSRuntime JSRuntime


<div class="rus-select">
    <RusInput @ref="rusInput" TValue="string" @bind-Value="displayValue" DisplayName="test" OnFocus="OnFocus" OnBlur="OnBlur" InputChanged="InputChanged" />
    <RusMenu T="T" IsOpen="menuOpen" IsOpenChanged="ShowMenuChanged">
        @if (loading)
        {
            <RusMenuItem Hoverable="false">
                <RusMenuItemContentLoading />
            </RusMenuItem>
        }
        else if (!filteredItems.Any())
        {
            <RusMenuItem Hoverable="false">
                <RusMenuItemContentNoResults />
            </RusMenuItem>
        }
        else
        {
            foreach (var item in filteredItems)
            {
                <RusMenuItem OnItemClick="@(async () => await SelectItem(item.Key))">
                    <RusMenuItemContentKeyValue Key="@item.Key.ToString()" Value="@(item.Value.Item1 + (item.Value.Item2 ? " (e)" : ""))" Multiselect="true" Checked="@(selectedValues.Contains(item.Key))" />
                </RusMenuItem>
            }
        }
    </RusMenu>
</div>

@code {
    [Parameter]
    public T Value { get; set; }

    [Parameter]
    public EventCallback<T> ValueChanged { get; set; }

    [Parameter]
    public Func<string, CancellationToken, Task<Dictionary<T, (string, bool)>>> GetOptionsAsync { get; set; }

    string id = "";
    bool loading = false;
    bool menuOpen = false;
    string? displayValue;
    string? lastVerifiedDisplayValue;
    private Timer? searchTimer;
    private CancellationTokenSource? cancellationTokenSource;
    Dictionary<T, (string, bool)>? options;
    Dictionary<T, (string, bool)> filteredItems = new();
    List<T> selectedValues = new();
    RusInput<string>? rusInput;

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            selectedValues.GetFlagsByValue(Value);
        }
        base.OnAfterRender(firstRender);
    }

    void OnFocus()
    {
        // Element may be re-focused from clicking in menu too.
        if (!menuOpen)
        {
            cancellationTokenSource?.Cancel();
            cancellationTokenSource = new CancellationTokenSource();
            CancellationToken cancellationToken = cancellationTokenSource.Token;

            Task.Run(async () =>
            {
                await UpdateList("", cancellationToken);
            });
        }
    }

    void OnBlur()
    {
        cancellationTokenSource?.Cancel();
    }

    void InputChanged(string input)
    {
        cancellationTokenSource?.Cancel();
        cancellationTokenSource = new CancellationTokenSource();
        CancellationToken cancellationToken = cancellationTokenSource.Token;

        searchTimer?.Dispose();
        searchTimer = new Timer(async (state) =>
        {
            if (!cancellationToken.IsCancellationRequested)
            {
                await UpdateList(input, cancellationToken);
            }
        }, null, 300, Timeout.Infinite);
    }

    async Task UpdateList(string search, CancellationToken token)
    {
        loading = true;
        menuOpen = true;
        await InvokeAsync(StateHasChanged);
        try
        {
            filteredItems = await SearchAsync(search, token);
        }
        catch (OperationCanceledException e)
        {
            // Search cancelled
        }
        loading = false;
        await InvokeAsync(StateHasChanged);
    }

    async Task SelectItem(T key)
    {
        // Toggle whether key is added or removed
        if (selectedValues.Contains(key))
        {
            selectedValues.Remove(key);
        }
        else
        {
            // Remove all keys if new key is exclusive,
            // or remove all exlusive keys if not
            if (filteredItems[key].Item2)
                selectedValues.Clear();
            else
                selectedValues.RemoveAll(i => filteredItems.TryGetValue(i, out var value) && value.Item2);

            selectedValues.Add(key);
        }

        // If 0 are selected, automatically select default (0)
        if (selectedValues.Count == 0)
        {
            selectedValues.Add(default(T));
        }

        Value = selectedValues.FlagsToValue();

        if (selectedValues.Count == 1)
        {
            displayValue = filteredItems[key].Item1;
        }
        else
        {
            displayValue = $"{selectedValues.Count} selected";
        }
        lastVerifiedDisplayValue = displayValue;

        var id = rusInput?.GetId() ?? "";
        await JSRuntime.InvokeVoidAsync("focusElement", id);
        _ = ValueChanged.InvokeAsync(Value);
    }

    void ShowMenuChanged(bool showMenu)
    {
        if (!showMenu)
            displayValue = lastVerifiedDisplayValue;
        menuOpen = showMenu;
    }

    async Task<Dictionary<T, (string, bool)>> SearchAsync(string input, CancellationToken token)
    {
        if(options == null)
        {
            var validOptions = await GetOptionsAsync.Invoke("", token);
            token.ThrowIfCancellationRequested();

            options = new();
            if (typeof(T).IsWholeNumberType())
                options[default(T)] = ("None", true);

            foreach (var validOption in validOptions)
                options[validOption.Key] = validOption.Value;

            if (typeof(T).IsWholeNumberType() && typeof(T).TryGetMaxValue<T>(out var maxValue))
            {
                var undefinedOptions = new List<T>();
                undefinedOptions.GetFlagsByValue(maxValue);
                foreach (var undefinedOption in undefinedOptions)
                    if (!options.ContainsKey(undefinedOption))
                        options[undefinedOption] = ("Undefined", false);
            }
        }

        var results = new Dictionary<T, (string, bool)>();
        var keyMatches = new List<T>();
        if (typeof(T).IsWholeNumberType() && input.TryParseAsT<T>(out var value))
        {
            keyMatches.GetFlagsByValue(value);
        }
        keyMatches.AddRange(options.Where(v => v.Value.Item1.Contains(input, StringComparison.InvariantCultureIgnoreCase)).Select(k => k.Key));

        token.ThrowIfCancellationRequested();
        foreach(var match in keyMatches)
        {
            if (options.ContainsKey(match))
                results[match] = options[match];
            else
                results[match] = new("Undefined", match.ToString().StartsWith("-")); // Negative values are always exclusive
        }

        if(!options.ContainsKey(Value))
            results[Value] = new("Undefined", Value.ToString().StartsWith("-"));

        return results;
    }
}