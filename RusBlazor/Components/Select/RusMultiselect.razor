@using RusBlazor.Components.Button
@typeparam T
@inject IJSRuntime JSRuntime


<div class="rus-select">
    <RusInput @ref="rusInput" TValue="string" @bind-Value="displayValue" DisplayName="test" OnFocus="OnFocus" OnBlur="OnBlur" InputChanged="InputChanged" HelperText="@($"{Value.ToString()} ({typeof(T)})")" />
    <RusMenu T="T" IsOpen="menuOpen" IsOpenChanged="ShowMenuChanged">
        <ControlContent>
            <RusMenuItem>
                <div style="display: flex; height: 30px;">
                    <RusButton Style="width:50%; height:100%;" Text="@(filteredItems.Count == options?.Count ? "Select all" : "Select filtered")" OnClick="SelectAll" Disabled="loading || !filteredItems.Any()"></RusButton>
                    <RusButton Style="width:50%; height:100%;" Text="@(filteredItems.Count == options?.Count ? "Deselect all" : "Deselect filtered")" OnClick="DeselectAll" Disabled="loading || !filteredItems.Any()"></RusButton>
                </div>
            </RusMenuItem>
        </ControlContent>
        <MenuContent>
            @if (loading)
            {
                <RusMenuItem Hoverable="false">
                    <RusMenuItemContentLoading />
                </RusMenuItem>
            }
            else if (!filteredItems.Any())
            {
                <RusMenuItem Hoverable="false">
                    <RusMenuItemContentText Text="No results" />
                </RusMenuItem>
            }
            else
            {
                foreach (var item in filteredItems)
                {
                    <RusMenuItem OnItemClick="@(async () => await SelectItem(item.Key))">
                        <RusMenuItemContentKeyValue Key="@item.Key.ToString()" Value="@(item.Value)" Multiselect="true" Checked="@(selectedValues.Contains(item.Key))" />
                    </RusMenuItem>
                }
            }
        </MenuContent>
    </RusMenu>
</div>

@code {
    [Parameter]
    public T Value { get; set; }

    [Parameter]
    public EventCallback<T> ValueChanged { get; set; }

    [Parameter]
    public Func<string, CancellationToken, Task<Dictionary<T, string>>> GetOptionsAsync { get; set; }

    string id = "";
    bool loading = false;
    bool menuOpen = false;
    string? displayValue;
    string? lastVerifiedDisplayValue;
    private Timer? searchTimer;
    private CancellationTokenSource? cancellationTokenSource;
    Dictionary<T, string>? options;
    Dictionary<T, string> filteredItems = new();
    List<T> selectedValues = new();
    RusInput<string>? rusInput;

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            selectedValues.GetFlagsByValue(Value);
        }
        base.OnAfterRender(firstRender);
    }

    void OnFocus()
    {
        // Element may be re-focused from clicking in menu too.
        if (!menuOpen)
        {
            cancellationTokenSource?.Cancel();
            cancellationTokenSource = new CancellationTokenSource();
            CancellationToken cancellationToken = cancellationTokenSource.Token;

            Task.Run(async () =>
            {
                await UpdateList("", cancellationToken);
            });
        }
    }

    void OnBlur()
    {
        cancellationTokenSource?.Cancel();
    }

    void InputChanged(string input)
    {
        cancellationTokenSource?.Cancel();
        cancellationTokenSource = new CancellationTokenSource();
        CancellationToken cancellationToken = cancellationTokenSource.Token;

        searchTimer?.Dispose();
        searchTimer = new Timer(async (state) =>
        {
            if (!cancellationToken.IsCancellationRequested)
            {
                await UpdateList(input, cancellationToken);
            }
        }, null, 300, Timeout.Infinite);
    }

    async Task UpdateList(string search, CancellationToken token)
    {
        loading = true;
        menuOpen = true;
        await InvokeAsync(StateHasChanged);
        try
        {
            filteredItems = await SearchAsync(search, token);
        }
        catch (OperationCanceledException e)
        {
            // Search cancelled
        }
        loading = false;
        await InvokeAsync(StateHasChanged);
    }

    void SelectAll()
    {
        if (filteredItems.Select(t => t.Key).ToList().TrySum<T>(out var sum))
        {
            Value = sum;
            selectedValues.GetFlagsByValue(sum);
            SetDisplayText();
        }
    }

    void DeselectAll()
    {
        if (filteredItems.Select(t => t.Key).ToList().TrySum<T>(out var sum))
        {
            var deselectedValues = new List<T>();
            deselectedValues.GetFlagsByValue(sum);
            foreach(var dValue in deselectedValues)
            {
                if (selectedValues.Contains(dValue))
                    selectedValues.Remove(dValue);
            }
            if(selectedValues.TrySum<T>(out var newSum))
            {
                Value = newSum;
            }
            else
            {
                throw new ThisShouldNotHappenException("Sum worked for T in first condition but not second.");
            }
            SetDisplayText();
        }
    }

    async Task SelectItem(T key)
    {
        // Toggle whether key is added or removed
        if (selectedValues.Contains(key))
        {
            selectedValues.Remove(key);
        }
        else
        {
            selectedValues.Add(key);
        }

        Value = selectedValues.GetValueByFlags();

        SetDisplayText();

        var id = rusInput?.GetId() ?? "";
        await JSRuntime.InvokeVoidAsync("focusElement", id);
        _ = ValueChanged.InvokeAsync(Value);
    }

    void ShowMenuChanged(bool showMenu)
    {
        if (!showMenu)
            displayValue = lastVerifiedDisplayValue;
        menuOpen = showMenu;
    }

    async Task<Dictionary<T, string>> SearchAsync(string input, CancellationToken token)
    {
        if (options == null)
        {
            var validOptions = await GetOptionsAsync.Invoke("", token);
            token.ThrowIfCancellationRequested();

            options = new();

            // Remove key 0. This is handled by menu automatically.
            if (typeof(T).IsWholeNumberType() && options.ContainsKey(default(T)))
                options.Remove(default(T));

            foreach (var validOption in validOptions)
                options[validOption.Key] = validOption.Value;

            if (typeof(T).IsWholeNumberType() && typeof(T).TryGetMaxValue<T>(out var maxValue))
            {
                var undefinedOptions = new List<T>();
                undefinedOptions.GetFlagsByValue(maxValue);
                foreach (var undefinedOption in undefinedOptions)
                    if (!options.ContainsKey(undefinedOption))
                        options[undefinedOption] = "Undefined";
            }
        }

        var results = new Dictionary<T, string>();
        var keyMatches = new List<T>();
        if (typeof(T).IsWholeNumberType() && input.TryParseAsT<T>(out var value))
        {
            keyMatches.GetFlagsByValue(value);
        }
        keyMatches.AddRange(options.Where(v => v.Value.Contains(input, StringComparison.InvariantCultureIgnoreCase)).Select(k => k.Key));

        token.ThrowIfCancellationRequested();
        foreach (var match in keyMatches)
        {
            if (options.ContainsKey(match))
                results[match] = options[match];
            else
                results[match] = new("Undefined");
        }

        return results;
    }

    void SetDisplayText()
    {
        if (selectedValues.Count == 0)
        {
            displayValue = "None";
        }
        else if (selectedValues.Count == 1)
        {
            displayValue = filteredItems[selectedValues.First()];
        }
        else
        {
            displayValue = $"{selectedValues.Count} selected";
        }
        lastVerifiedDisplayValue = displayValue;
    }
}