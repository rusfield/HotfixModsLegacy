@typeparam T

@using HotfixMods.Infrastructure.Blazor.Business
@using System.ComponentModel;

@if (null == options)
{
    <Placeholder_Element Visible="true" IsNested="true" />
}
else
{
    <MudAutocomplete @ref="mudAutocompleteRef" T="string" Value="@ShowValue()" Text="@ShowValue()" ValueChanged="InputValueChanged" Label="@Label" SelectValueOnTab="true" Variant="@Variant" SearchFunc="@Search" HelperText="@(ComponentHelper.GetHelperText<T>())" HelperTextOnFocus="true" MaxItems="maxItems" ShowProgressIndicator="true" Adornment="Adornment" AdornmentIcon="@AdornmentIcon" OnAdornmentClick="OnAdornmentClick" Error="Error" ErrorText="Enter a valid value." Disabled="Disabled" Class="adornment-clickable" CoerceValue="true" Strict="false">
        <NoItemsTemplate>
            <MudList Clickable="true">
                <MudListItem>
                    @Value
                </MudListItem>
            </MudList>
        </NoItemsTemplate>
        <MoreItemsTemplate>
            <MudText Typo="Typo.subtitle2" Style="color:var(--mud-palette-action-disabled)" Align="Align.Center">@(searchResultCount - maxItems) more options...</MudText>
        </MoreItemsTemplate>
    </MudAutocomplete>
}


@code {
    [CascadingParameter(Name = "RefreshElement")]
    public bool RefreshElement { get; set; }

    [CascadingParameter(Name = "CurrentPageIndex")]
    public int CurrentPageIndex { get; set; } // Used to close menu when index is changed.

    [Parameter]
    public string? Label { get; set; }

    [Parameter]
    public T? Value { get; set; }

    [Parameter]
    public Func<Task<Dictionary<T, string>>> GetOptionsAsync_Func { get; set; }

    [Parameter]
    public EventCallback<T?> ValueChanged { get; set; }

    [Parameter]
    public Variant Variant { get; set; } = Variant.Outlined;

    [Parameter]
    public string AdornmentIcon { get; set; }

    [Parameter]
    public EventCallback OnAdornmentClick { get; set; }

    [Parameter]
    public Adornment Adornment { get; set; }

    [Parameter]
    public bool Error { get; set; }

    [Parameter]
    public bool Disabled { get; set; } = false;

    string? _inputValue;
    MudAutocomplete<string>? mudAutocompleteRef;
    Dictionary<T, string>? options;
    bool refreshElement = false;
    int previousPageIndex = 0;
    int maxItems = 50;
    int searchResultCount = 0;

    protected override void OnParametersSet()
    {
        if (previousPageIndex != CurrentPageIndex && mudAutocompleteRef != null && mudAutocompleteRef.IsOpen)
        {
            mudAutocompleteRef.ToggleMenu();
        }
        previousPageIndex = CurrentPageIndex;
        base.OnParametersSet();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender || refreshElement != RefreshElement)
        {
            options = await GetOptionsAsync_Func.Invoke();
            searchResultCount = options.Count;
            refreshElement = RefreshElement;
            this.StateHasChanged();
        }
        await base.OnAfterRenderAsync(firstRender);
    }

    async Task InputValueChanged(string input)
    {
        mudAutocompleteRef?.ToggleMenu();
        string type = (Nullable.GetUnderlyingType(typeof(T)) ?? typeof(T)).ToString();
        var listItem = options.Where(x => x.Value.Equals(input, StringComparison.InvariantCultureIgnoreCase) || x.Key.ToString() == input);
        var value = listItem.Count() > 0 ? listItem.First().Key.ToString() : input;

        if ("System.SByte" == type && sbyte.TryParse(value, out var sbyteValue))
        {
            Value = (T)Convert.ChangeType(sbyteValue, typeof(sbyte));
        }
        else if ("System.Byte" == type && byte.TryParse(value, out var byteValue))
        {
            Value = (T)Convert.ChangeType(byteValue, typeof(byte));
        }
        else if ("System.Int16" == type && short.TryParse(value, out var shortValue))
        {
            Value = (T)Convert.ChangeType(shortValue, typeof(short));
        }
        else if ("System.UInt16" == type && ushort.TryParse(value, out var ushortValue))
        {
            Value = (T)Convert.ChangeType(ushortValue, typeof(ushort));
        }
        else if ("System.Int32" == type && int.TryParse(value, out var intValue))
        {
            Value = (T)Convert.ChangeType(intValue, typeof(int));
        }
        else if ("System.UInt32" == type && uint.TryParse(value, out var uintValue))
        {
            Value = (T)Convert.ChangeType(uintValue, typeof(uint));
        }
        else if ("System.Int64" == type && long.TryParse(value, out var longValue))
        {
            Value = (T)Convert.ChangeType(longValue, typeof(long));
        }
        else if ("System.UInt64" == type && ulong.TryParse(value, out var ulongValue))
        {
            Value = (T)Convert.ChangeType(ulongValue, typeof(ulong));
        }
        else if ("System.Decimal" == type && decimal.TryParse(value, out var decimalValue))
        {
            Value = (T)Convert.ChangeType(decimalValue, typeof(decimal));
        }
        else if ("System.String" == type && value != null)
        {
            Value = (T)Convert.ChangeType(value, typeof(string));
        }
        else
        {
            Value = default(T);
        }

        await ValueChanged.InvokeAsync(Value);
    }

    async Task<IEnumerable<string>> Search(string value)
    {
        SetError(false);
        var results = new List<string>();
        await Task.Run(() =>
        {
            if (string.IsNullOrEmpty(value))
            {
                results = options.Select(o => o.Value).Distinct().ToList(); // Read reason for .Distinct() below
            }
            else
            {
                var filteredOptions = options.Where(o => o.Value.Contains(value, StringComparison.InvariantCultureIgnoreCase) || o.Key.ToString().Equals(value, StringComparison.InvariantCultureIgnoreCase)).Select(o => o.Value).ToList();
                if (!options.Any(o => o.Key.ToString().Equals(value, StringComparison.InvariantCultureIgnoreCase) || o.Value.ToString().Equals(value, StringComparison.InvariantCultureIgnoreCase)))
                {
                    // Add value to list to support options that are not loaded.
                    try
                    {
                        var converter = TypeDescriptor.GetConverter(typeof(T));
                        var convertedValue = converter.ConvertFromInvariantString(value);
                        filteredOptions.Add(value);
                    }
                    catch
                    {
                        /* Value is not supported */
                    }
                }

                // MudAutocomplete does not support search results with the same display value.
                // To counter this, consider naming the display string differently.
                results = filteredOptions.Distinct().ToList();
            }
        });
        searchResultCount = results.Count;
        return results;
    }

    string? ShowValue()
    {
        if (null == Value)
            return "";

        var option = options!.Where(x => x.Value.Equals(Value.ToString() ?? "", StringComparison.InvariantCultureIgnoreCase) || x.Key.ToString().Equals(Value.ToString())).Select(x => x.Value).FirstOrDefault();
        return (option ?? Value.ToString()) ?? "Error loading value";
    }

    public void SetError(bool newError)
    {
        if (Error != newError)
        {
            Error = newError;
            this.StateHasChanged();
        }
    }
}
