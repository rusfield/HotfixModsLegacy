@using RusBlazor.Components.Helpers
@using RusBlazor.Enums
@typeparam T

@inject IJSRuntime JSRuntime

@if (IsOpen)
{
    <div class="@("rus-menu")" style="@($"{StateStyle()} {AnchorStyle()}")" id="@(parentContainerId)">

        @if (MenuTopContent != null)
        {
            <div class="rus-menu-top">
                @MenuTopContent
            </div>
        }

        @if (MenuContent != null)
        {
            <div class="rus-menu-dropdown" id="@id" style="@($"height:{dropdownHeight}px;")">
                @MenuContent
            </div>
        }

        @if (MenuBottomContent != null)
        {
            <div class="rus-menu-bottom">
                @MenuBottomContent
            </div>
        }

    </div>
    <RusBackgroundOverlay OnClick="CloseAsync" />
}


@code {
    [Parameter]
    public bool IsOpen { get; set; }

    [Parameter]
    public EventCallback<(bool, int)> IsOpenChanged { get; set; }

    [Parameter]
    public Anchor Anchor { get; set; } = Anchor.Auto;

    [Parameter]
    public RenderFragment? MenuContent { get; set; }

    [Parameter]
    public RenderFragment? MenuTopContent { get; set; }

    [Parameter]
    public RenderFragment? MenuBottomContent { get; set; }

    string id;
    string parentContainerId;
    int animationDurationMs = 200;
    int dropdownHeight = 240;

    protected override void OnInitialized()
    {
        id = Guid.NewGuid().ToString();
        parentContainerId = Guid.NewGuid().ToString();
        base.OnInitialized();
    }

    string AnchorStyle()
    {
        return Anchor switch
        {
            Anchor.Bottom => "top: 100%; left: 0;",
            Anchor.Top => "bottom: 100%; left: 0;",
            Anchor.Left => "right: 100%; top: 0;",
            Anchor.Right => "left: 100%; top: 0;",
            Anchor.BottomLeft => "top: 100%; right: 0;",
            Anchor.BottomRight => "top: 100%; left: 0;",
            Anchor.TopLeft => "bottom: 100%; right: 0;",
            Anchor.TopRight => "bottom: 100%; left: 0;",
            _ => "top: 100%; left: 0;",
        };
    }

    string StateStyle()
    {
        return IsOpen ? "display:block;" : "display:none;";
    }

    public async Task OpenAsync()
    {
        if (!IsOpen)
        {
            await JSRuntime.InvokeVoidAsync("toggleDropdownHeight", id, true, dropdownHeight, animationDurationMs);
            await JSRuntime.InvokeVoidAsync("toggleDropdownOpacity", parentContainerId, true, animationDurationMs);

            await InvokeAsync(async () =>
            {
                await IsOpenChanged.InvokeAsync((true, animationDurationMs));
            });
            IsOpen = true;
        }
        else
        {
            // Trigger for outside components
            await InvokeAsync(async () =>
            {
                await IsOpenChanged.InvokeAsync((true, 0));
            });
        }
    }

    public async Task CloseAsync()
    {
        if (IsOpen)
        {
            await JSRuntime.InvokeVoidAsync("toggleDropdownHeight", id, false, dropdownHeight, animationDurationMs);
            await JSRuntime.InvokeVoidAsync("toggleDropdownOpacity", parentContainerId, false, animationDurationMs / 2);

            await InvokeAsync(async () =>
            {
                await IsOpenChanged.InvokeAsync((false, animationDurationMs));
            });
            await Task.Delay(animationDurationMs);
            IsOpen = false;
        }
        else
        {
            // Trigger for outside components
            await InvokeAsync(async () =>
            {
                await IsOpenChanged.InvokeAsync((false, 0));
            });
        }
    }

    public string GetId()
    {
        return id;
    }
}